### Ribbon架构设计

#### 整体组件:

##### 负载均衡器

ILoadBalancer

1. 添加服务列表
2. 选择一个服务
3. 标记一个服务下线
4. 获取服务列表(全部,健在,下线)

BaseLoadBalancer

1. 负载均衡的策略 IRule (之后着重来讲)
2. 服务列表(所有的服务) List<Server>
3. 在线的服务列表(健在) List<Server>
4. ping的策略 IPingStrategy (多个服务列表的形式)以及ping的方式 IPing => 并且他们ping是有时间间隔
5. 和一些操作的监听器(服务列表发生改变时候,主要用作扩展,ServerListChangeListener,ServerStatusChangeListener)

注意: 2-3点的服务列表是经过一系列操作之后的服务列表

2个具体实现类:

1. DynamicServerListLoadBalancer 基于动态获取服务列表(从注册中心来获取的能力),或者通过固定的配置能力
2. ZoneAwareLoadBalancer 在动态的基础之上,一个服务名称可能存在不同的分区,主要是 Server的属性里面zone的名称来区分

DynamicServerListLoadBalancer介绍

1. 拥有服务列表(从注册中心,或者写死配置), 服务列表的来源 ServerList
2. 服务列表的过滤 ServerListFilter (主要将服务列表来源的服务进行过滤),有2个实现类 ZoneAffinityServerListFilter,ServerListSubsetFilter
3. 服务列表的更新者 ServerListUpdater( 主要部分结合了 1,2的操作,得到一个服务列表,然后设置到负载均衡器里面的服务列表里面去,并且会进行ping的操作
   如果实现类是ZoneAwareLoadBalancer的负载均衡器,会为每个服务分区设置一个均衡器)

ZoneAwareLoadBalancer介绍

1. 在上面的基础上就是不同的分区拥有不同的负载均衡器(采用了装饰者模式),主要和上面的区别就是,在选择服务的时候,会对每个分区的服务 进行一些数据上的比较(这些数据是有专门的统计模块来进行统计),以至于选择那个分区的负载均衡器进行调用

##### ServerStats

负载均衡中服务列表的一些统计信息 请求响应的时间,异常个数等等

##### Server: 代表一个服务

1. host
2. port
3. 协议: http,https等等
4. zone(该服务所处分区)
5. 如果要扩展的话,你可以继承该类

##### 注册中心和ribbon的整合:

```text
要和注册中心整合的心得:
假设你的注册中心是nacos,那我们应该继承Server来实现一些特殊的功能或者其他功能 并且也要实现 服务列表(服务的来源), ServerList这个接口, 同时
你对服务列表的更新的逻辑也有想法的话,你也可以重实现它,并且ping的方式你也可以重实现

官方的整合的实例:
下面ribbon整合eureka的事例:
项目 ribbon-eureka

1. DiscoveryEnabledNIWSServerList (服务列表,服务的来源)
2. DiscoveryEnabledServer  (服务)
3. EurekaNotificationServerListUpdater (服务列表的更新者)
4. NIWSDiscoveryPing (ping的方式)
```

##### 负载均衡策略 IRule

###### RoundRobinRule

其实对于以下代码,可以改成 LongAdder效率较高 ,

对于该负载均衡的优点

1. 对每个机器都是平等的对待,不可能存在流量倾斜的情况

对于该负载均衡的缺点:

1. 由于提供服务的机器有优劣之分, 有些好的机器和比较差的机器他们承受流量的大小是不同的,这就会导致好的机器没有得到充分的利用,比较差的机器反而 会受到的压力就会很大

```java
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

public class RoundRobinRule extends AbstractLoadBalancerRule {

    private AtomicInteger nextServerCyclicCounter;
    private static final boolean AVAILABLE_ONLY_SERVERS = true;
    private static final boolean ALL_SERVERS = false;

    private static Logger log = LoggerFactory.getLogger(RoundRobinRule.class);

    public RoundRobinRule() {

    }

    public RoundRobinRule(ILoadBalancer lb) {
        this();
        setLoadBalancer(lb);
    }

    public Server choose(ILoadBalancer lb, Object key) {
        if (lb == null) {
            log.warn("no load balancer");
            return null;
        }

        Server server = null;
        int count = 0;
        while (server == null && count++ < 10) {
            List<Server> reachableServers = lb.getReachableServers();
            List<Server> allServers = lb.getAllServers();
            int upCount = reachableServers.size();
            int serverCount = allServers.size();

            if ((upCount == 0) || (serverCount == 0)) {
                log.warn("No up servers available from load balancer: " + lb);
                return null;
            }

            int nextServerIndex = incrementAndGetModulo(serverCount);
            server = allServers.get(nextServerIndex);

            if (server == null) {
                /* Transient. */
                Thread.yield();
                continue;
            }

            if (server.isAlive() && (server.isReadyToServe())) {
                return (server);
            }

            // Next.
            server = null;
        }

        if (count >= 10) {
            log.warn("No available alive servers after 10 tries from load balancer: "
                    + lb);
        }
        return server;
    }


    private int incrementAndGetModulo(int modulo) {
        for (; ; ) {
            int current = nextServerCyclicCounter.get();
            int next = (current + 1) % modulo;
            if (nextServerCyclicCounter.compareAndSet(current, next))
                return next;
        }
    }

    @Override
    public Server choose(Object key) {
        return choose(getLoadBalancer(), key);
    }
}
```

###### RetryRule

采用了装饰者模式,重试里面可以包裹了其他类型的负载均衡器,默认包括的负载均衡是 轮训的负载均衡器

```java
public class RetryRule extends AbstractLoadBalancerRule {
    IRule subRule = new RoundRobinRule();
    long maxRetryMillis = 500;

    public RetryRule() {
    }

    public RetryRule(IRule subRule) {
        this.subRule = (subRule != null) ? subRule : new RoundRobinRule();
    }

    public RetryRule(IRule subRule, long maxRetryMillis) {
        this.subRule = (subRule != null) ? subRule : new RoundRobinRule();
        this.maxRetryMillis = (maxRetryMillis > 0) ? maxRetryMillis : 500;
    }

    public void setRule(IRule subRule) {
        this.subRule = (subRule != null) ? subRule : new RoundRobinRule();
    }

    public IRule getRule() {
        return subRule;
    }

    public void setMaxRetryMillis(long maxRetryMillis) {
        if (maxRetryMillis > 0) {
            this.maxRetryMillis = maxRetryMillis;
        } else {
            this.maxRetryMillis = 500;
        }
    }

    public long getMaxRetryMillis() {
        return maxRetryMillis;
    }


    @Override
    public void setLoadBalancer(ILoadBalancer lb) {
        super.setLoadBalancer(lb);
        subRule.setLoadBalancer(lb);
    }

    /*
     * Loop if necessary. Note that the time CAN be exceeded depending on the
     * subRule, because we're not spawning additional threads and returning
     * early.
     */
    public Server choose(ILoadBalancer lb, Object key) {
        long requestTime = System.currentTimeMillis();
        long deadline = requestTime + maxRetryMillis;

        Server answer = null;

        answer = subRule.choose(key);

        if (((answer == null) || (!answer.isAlive()))
                && (System.currentTimeMillis() < deadline)) {

            //到了时间就会进行打断
            InterruptTask task = new InterruptTask(deadline
                    - System.currentTimeMillis());


            while (!Thread.interrupted()) {
                //如果没有被打断,就继续去选择服务
                answer = subRule.choose(key);

                //然后再次进行选择服务的判断(服务是否为null,服务是否存活,并且重试的时间是否过了)
                if (((answer == null) || (!answer.isAlive()))
                        && (System.currentTimeMillis() < deadline)) {
                    /* pause and retry hoping it's transient */
                    //如果服务还是不行,就当前线程放弃执行的机会(但是也会重新争夺机会)
                    Thread.yield();
                } else {
                    //说明服务是可行的
                    break;
                }
            }

            //将打断任务进行取消
            task.cancel();
        }

        if ((answer == null) || (!answer.isAlive())) {
            return null;
        } else {
            return answer;
        }
    }

    @Override
    public Server choose(Object key) {
        return choose(getLoadBalancer(), key);
    }
}
```

###### RandomRule

随机的策略

随机的话,可能造成一种流量的倾斜吧

```java
public class RandomRule extends AbstractLoadBalancerRule {

    /**
     * Randomly choose from all living servers
     */
    @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE")
    public Server choose(ILoadBalancer lb, Object key) {
        if (lb == null) {
            return null;
        }
        Server server = null;

        while (server == null) {
            if (Thread.interrupted()) {
                return null;
            }
            List<Server> upList = lb.getReachableServers();
            List<Server> allList = lb.getAllServers();

            int serverCount = allList.size();
            if (serverCount == 0) {
                /*
                 * No servers. End regardless of pass, because subsequent passes
                 * only get more restrictive.
                 */
                return null;
            }

            int index = chooseRandomInt(serverCount);
            server = upList.get(index);

            if (server == null) {
                /*
                 * The only time this should happen is if the server list were
                 * somehow trimmed. This is a transient condition. Retry after
                 * yielding.
                 */
                Thread.yield();
                continue;
            }

            if (server.isAlive()) {
                return (server);
            }

            // Shouldn't actually happen.. but must be transient or a bug.
            server = null;
            Thread.yield();
        }

        return server;

    }

    protected int chooseRandomInt(int serverCount) {
        return ThreadLocalRandom.current().nextInt(serverCount);
    }

    @Override
    public Server choose(Object key) {
        return choose(getLoadBalancer(), key);
    }
}
```

######            